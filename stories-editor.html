<!DOCTYPE html>
<html class="dark" lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Editor de Stories</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdn.tailwindcss.com?plugins=forms,typography"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <script>
    tailwind.config = {
      darkMode: "class",
      theme: {
        extend: {
          colors: {
            primary: '#E11D48',
            "background-dark": "#111827",
          },
          fontFamily: {
            display: ["Roboto", "sans-serif"],
          },
        },
      },
    };
  </script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body, #root { height: 100%; }
    .thumbnail-item { transition: transform 0.15s, opacity 0.15s; }
    .thumbnail-item.dragging { opacity: 0.5; transform: scale(0.95); }
    .material-icons { font-size: 20px; }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useRef, useEffect } = React;

    // CALENDARIO DE GUIONES (16 d√≠as de contenido)
    const GUIONES_CALENDARIO = {
      // LUNES - Calculadoras
      'lun-1': {
        titulo: 'Plusval√≠a Municipal',
        textos: [
          'Cuando vendes tu piso, tienes 30 d√≠as para pagar la plusval√≠a municipal.',
          'Hay 2 m√©todos para calcular cu√°nto te toca pagar. El m√©todo objetivo, y el m√©todo REAL.',
          'Con esta calculadora sabr√°s exactamente cu√°l es el m√©todo que te sale m√°s barato'
        ],
        fotos: ['üë§ Agente serio', 'üìÑ Documentos', 'üì± Calculadora', 'üí¨ CTA "PLUSVAL√çA"']
      },
      'lun-2': {
        titulo: 'Impuesto de Sucesiones',
        textos: [
          'Si quieres vender una vivienda HEREDADA, tienes 6 meses para liquidar el impuesto',
          'Si tardas m√°s de 12 meses el recargo sube',
          'Esta calculadora te dice exactamente cu√°nto te tocar√° pagar'
        ],
        fotos: ['üë§ Agente', 'üìÑ Documentos mesa', 'üì± Calculadora', 'üí¨ CTA "HERENCIA"']
      },
      'lun-3': {
        titulo: 'IRPF (Ganancia Patrimonial)',
        textos: [
          'Vendes tu piso por 300.000‚Ç¨ y al a√±o siguiente Hacienda te reclama 15.000‚Ç¨',
          'La ganancia patrimonial por vender una vivienda suele pillar de sorpresa',
          'Con esta calculadora sabr√°s exactamente cu√°nto debes apartar'
        ],
        fotos: ['üë§ Agente serio', 'üòü Preocupaci√≥n', 'üì± Calculadora', 'üí¨ CTA "RENTA"']
      },
      
      // MI√âRCOLES - Tutoriales
      'mie-1': {
        titulo: 'Nota Simple',
        textos: [
          'Antes de vender necesitas saber si tiene cargas o embargos',
          'Si aparece una carga cuando ya tienes comprador se echa atr√°s',
          'He grabado un v√≠deo para ense√±arte c√≥mo sacarla por solo 9 euros'
        ],
        fotos: ['üë§ Agente', 'üòê Gesto serio', 'üì± Pantalla Registro', 'üí¨ CTA "NOTA"']
      },
      'mie-2': {
        titulo: 'Precios CEE',
        textos: [
          'Si NO tienes el certificado energ√©tico no puedes publicar tu vivienda',
          'Si firmas arras sin tenerlo el comprador puede echarse atr√°s sin penalizaci√≥n',
          'En este listado oficial puedes buscar t√©cnicos y comparar precios'
        ],
        fotos: ['üë§ Agente', 'üòê Serio', 'üì± Web oficial', 'üí¨ CTA "PRECIOS"']
      },
      'mie-3': {
        titulo: 'Notarios',
        textos: [
          'A veces tu piso vale m√°s de lo que crees',
          'Los notarios han sacado una web donde puedes ver los precios escriturados reales',
          'Son datos oficiales, no estimaciones'
        ],
        fotos: ['üë§ Agente', 'üì± Web notarios', 'üìä Datos', 'üí¨ CTA "NOTARIOS"']
      },
      'mie-4': {
        titulo: 'Catastro',
        textos: [
          'Si hay discrepancias entre los metros de escritura y Catastro el notario paraliza la venta',
          'En la Sede del Catastro puedes sacar todo online y gratis',
          'He grabado un v√≠deo r√°pido para ense√±arte c√≥mo'
        ],
        fotos: ['üë§ Agente', 'üì± Sede Catastro', 'üé• Captura v√≠deo', 'üí¨ CTA "CATASTRO"']
      },
      
      // JUEVES - Lead magnets personalizados
      'jue-1': {
        titulo: 'Testigos de Ventas',
        textos: [
          'Si te f√≠as de Idealista te arriesgas a vender por debajo del precio real',
          'Los testigos se sacan del registro y te salen las ventas oficiales',
          'No estimaciones, precios oficiales escriturados'
        ],
        fotos: ['üë§ Agente', 'üë• Reuni√≥n', 'üìÑ Testigos', 'üí¨ CTA "VENTAS"']
      },
      'jue-2': {
        titulo: 'Asesor√≠a Impuestos',
        textos: [
          'No ten√≠a ni idea de todo lo que me pod√≠a ahorrar al vender el piso',
          'Entre bonificaciones, exenciones, deducciones... incluso evitar multas',
          'Asesor√≠as por videollamada sin que tengas que desplazarte'
        ],
        fotos: ['üë§ Agente', 'üíª Zoom', 'üì± Videollamada', 'üí¨ CTA "IMPUESTOS"']
      },
      'jue-3': {
        titulo: 'Ayuda Plusval√≠a',
        textos: [
          'La plusval√≠a municipal es el PRIMER hachazo de hacienda',
          'Cada ayuntamiento tiene sus propios coeficientes',
          'Te ayudo a calcularla y te digo exactamente cu√°l te sale m√°s barato'
        ],
        fotos: ['üë§ Agente', 'üìÑ Papeles', 'üßÆ C√°lculo', 'üí¨ CTA "AYUDA"']
      },
      
      // DOMINGO - Presenciales
      'dom-1': {
        titulo: 'CEE Incluido',
        textos: [
          'Para vender necesitas S√ç o S√ç el CEE en vigor',
          'Nosotros incluimos el CEE SIN coste adicional',
          'Voy a tu casa, hago mediciones y te entrego el certificado oficial en 48h'
        ],
        fotos: ['üë§ Agente', 'üìã Tablet', 'üìê Mediciones', 'üí¨ CTA "CEE"']
      },
      'dom-2': {
        titulo: 'Tasaci√≥n a Domicilio',
        textos: [
          'Carlos iba a poner su piso seg√∫n Idealista y habr√≠a perdido 45.000‚Ç¨',
          'Las valoraciones online NO tienen en cuenta el estado real',
          'Solo con tasaci√≥n a domicilio puedes poner el precio exacto'
        ],
        fotos: ['üë§ Agente', 'üìê Valoraci√≥n', 'üìã Tablet', 'üí¨ CTA "TASACI√ìN"']
      },
      'dom-3': {
        titulo: 'CEE Obligatorio',
        textos: [
          'Si vendes sin CEE en vigor te arriesgas a perder la venta',
          'Un notario se neg√≥ a firmar sin el CEE y el comprador se ech√≥ atr√°s',
          'El CEE es el primer paso que tienes que dar'
        ],
        fotos: ['üë§ Agente', 'üòê Serio', 'üìê Mediciones', 'üí¨ CTA "CEE"']
      },
      'dom-4': {
        titulo: 'Tasaci√≥n Realista',
        textos: [
          'Si te gu√≠as por tus emociones o lo que necesitas para la hipoteca te arriesgas',
          'Carlos no hizo caso a la valoraci√≥n: 27 visitas, 3 ofertas, ninguna seria',
          'Valoraci√≥n a domicilio para vender bien y evitar quebraderos de cabeza'
        ],
        fotos: ['üë§ Agente', 'üìê Valoraci√≥n', 'üòê Serio', 'üí¨ CTA "TASACI√ìN"']
      }
    };

    // Mapeo de d√≠as de la semana a claves de calendario
    const DAY_TO_CALENDAR_KEY = {
      'Lun': ['lun-1', 'lun-2', 'lun-3', 'lun-1'], // Cicla cada 3 semanas
      'Mar': [null, null, null, null],
      'Mie': ['mie-1', 'mie-2', 'mie-3', 'mie-4'],
      'Jue': ['jue-1', 'jue-2', 'jue-3', 'jue-1'],
      'Vie': [null, null, null, null],
      'Sab': [null, null, null, null],
      'Dom': ['dom-1', 'dom-2', 'dom-3', 'dom-4']
    };

    function StoriesEditor() {
      const DAYS = ['Lun', 'Mar', 'Mie', 'Jue', 'Vie', 'Sab', 'Dom'];
      const FONTS = [
        { id: 'instagram', name: 'Instagram', fontFamily: 'Inter, -apple-system, BlinkMacSystemFont, sans-serif', fontWeight: 700 },
        { id: 'classic', name: 'Classic', fontFamily: 'Georgia, serif', fontWeight: 700 },
        { id: 'strong', name: 'Strong', fontFamily: 'Impact, sans-serif', fontWeight: 900 },
        { id: 'typewriter', name: 'Typewriter', fontFamily: 'Courier New, monospace', fontWeight: 700 }
      ];
      const DRAW_COLORS = ['#FFFFFF', '#000000', '#FF3B30', '#FF9500', '#FFCC00', '#34C759', '#007AFF', '#AF52DE', '#FF2D55', '#00FFFF', '#FF00FF', '#00FF00'];
      const TEXT_COLORS = ['#FFFFFF', '#000000', '#FF3B30', '#FFCC00', '#34C759', '#007AFF'];
      const MAX_CHARS_WIDE = 40;
      const MAX_CHARS_NARROW = 25;

      // Leer blogId de la URL
      const [blogId, setBlogId] = useState(null);
      const [weekNumber, setWeekNumber] = useState(0); // 0-3 para ciclar las semanas

      useEffect(() => {
        const params = new URLSearchParams(window.location.search);
        const cuenta = params.get('cuenta');
        if (cuenta) {
          setBlogId(cuenta);
        } else {
          alert('Error: No se ha especificado cuenta. La URL debe ser: ?cuenta=XXXXX');
        }
      }, []);

      const [stories, setStories] = useState(DAYS.map(day => ({ day, slots: [null, null, null, null], texts: [[], [], [], []], drawings: [[], [], [], []], overlays: [[], [], [], []] })));
      const [activeDayIdx, setActiveDayIdx] = useState(0);
      const [activeSlotIdx, setActiveSlotIdx] = useState(0);
      const [selectedElements, setSelectedElements] = useState([]);
      const [selectedDrawingId, setSelectedDrawingId] = useState(null);
      const [selectedThumbIdx, setSelectedThumbIdx] = useState(null);
      const [tool, setTool] = useState('select');
      const [drawColor, setDrawColor] = useState('#FFFFFF');
      const [brushStyle, setBrushStyle] = useState('normal');
      const [brushTip, setBrushTip] = useState('normal');
      const [brushSize, setBrushSize] = useState(5);
      const [isDrawing, setIsDrawing] = useState(false);
      const [currentPath, setCurrentPath] = useState([]);
      const [draggedThumb, setDraggedThumb] = useState(null);
      const [showPublishModal, setShowPublishModal] = useState(false);
      const [publishHour, setPublishHour] = useState('09:00');
      const [isPublishing, setIsPublishing] = useState(false);

      const fileInputRef = useRef(null);
      const overlayInputRef = useRef(null);
      const canvasRef = useRef(null);

      const currentStory = stories[activeDayIdx];
      const currentImage = currentStory.slots[activeSlotIdx];
      const currentTexts = currentStory.texts[activeSlotIdx];
      const currentDrawings = currentStory.drawings[activeSlotIdx];
      const currentOverlays = currentStory.overlays[activeSlotIdx];

      // Obtener gui√≥n del d√≠a actual
      const getCurrentGuion = () => {
        const dayName = DAYS[activeDayIdx];
        const calendarKeys = DAY_TO_CALENDAR_KEY[dayName];
        if (!calendarKeys) return null;
        const key = calendarKeys[weekNumber % calendarKeys.length];
        return key ? GUIONES_CALENDARIO[key] : null;
      };

      const currentGuion = getCurrentGuion();

      useEffect(() => {
        const handleKeyDown = (e) => {
          if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') return;
          
          if (e.key === 'Delete' || e.key === 'Backspace') {
            e.preventDefault();
            if (selectedElements.length > 0) deleteSelected();
            else if (selectedDrawingId) deleteDrawing(selectedDrawingId);
            else if (selectedThumbIdx !== null) deleteSlot(selectedThumbIdx);
          }
          
          if (e.key === ' ') {
            e.preventDefault();
            if (selectedElements.length > 0) {
              selectedElements.forEach(sel => {
                if (sel.type === 'text') {
                  const text = currentTexts.find(t => t.id === sel.id);
                  if (text) {
                    const isWide = text.maxChars === MAX_CHARS_WIDE;
                    updateText(sel.id, { maxChars: isWide ? MAX_CHARS_NARROW : MAX_CHARS_WIDE });
                  }
                }
              });
            } else if (selectedDrawingId) {
              const drawing = currentDrawings.find(d => d.id === selectedDrawingId);
              if (drawing) {
                updateDrawing(selectedDrawingId, { style: drawing.style === 'neon' ? 'normal' : 'neon' });
              }
            }
          }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [selectedElements, selectedDrawingId, selectedThumbIdx, activeDayIdx, activeSlotIdx, currentTexts, currentDrawings]);

      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        
        const handleWheel = (e) => {
          const delta = e.deltaY > 0 ? -1 : 1;
          
          if (selectedDrawingId) {
            e.preventDefault();
            const drawing = currentDrawings.find(d => d.id === selectedDrawingId);
            if (drawing) updateDrawing(selectedDrawingId, { size: Math.max(2, Math.min(30, drawing.size + delta)) });
            return;
          }
          
          if (selectedElements.length > 0) {
            e.preventDefault();
            selectedElements.forEach(sel => {
              if (sel.type === 'text') {
                const text = currentTexts.find(t => t.id === sel.id);
                if (text) {
                  if (e.ctrlKey || e.metaKey) {
                    const newTexts = currentTexts.map(t => t.id === sel.id ? { ...t, rotation: ((t.rotation || 0) + delta * 5 + 360) % 360 } : t);
                    updateStory(activeDayIdx, 'texts', activeSlotIdx, newTexts);
                  } else if (e.shiftKey) {
                    const currentOpacity = text.bgOpacity ?? 1;
                    const newTexts = currentTexts.map(t => t.id === sel.id ? { ...t, bgOpacity: Math.max(0, Math.min(1, currentOpacity + delta * 0.1)) } : t);
                    updateStory(activeDayIdx, 'texts', activeSlotIdx, newTexts);
                  } else {
                    const newTexts = currentTexts.map(t => t.id === sel.id ? { ...t, fontSize: Math.max(14, Math.min(72, t.fontSize + delta * 2)) } : t);
                    updateStory(activeDayIdx, 'texts', activeSlotIdx, newTexts);
                  }
                }
              } else if (sel.type === 'overlay') {
                const overlay = currentOverlays.find(o => o.id === sel.id);
                if (overlay) {
                  const newW = Math.max(30, overlay.width + delta * 8);
                  const newH = newW / overlay.aspectRatio;
                  const newOverlays = currentOverlays.map(o => o.id === sel.id ? { ...o, width: newW, height: newH } : o);
                  updateStory(activeDayIdx, 'overlays', activeSlotIdx, newOverlays);
                }
              }
            });
          }
        };
        canvas.addEventListener('wheel', handleWheel, { passive: false });
        return () => canvas.removeEventListener('wheel', handleWheel);
      }, [selectedElements, selectedDrawingId, currentTexts, currentOverlays, currentDrawings, activeDayIdx, activeSlotIdx]);

      const updateStory = (dayIdx, field, slotIdx, value) => {
        setStories(prev => { 
          const newStories = [...prev]; 
          const newData = [...newStories[dayIdx][field]]; 
          newData[slotIdx] = value; 
          newStories[dayIdx] = { ...newStories[dayIdx], [field]: newData }; 
          return newStories; 
        });
      };

      const handleImageUpload = (e) => {
        Array.from(e.target.files).forEach((file, i) => {
          if (activeSlotIdx + i < 4) {
            const reader = new FileReader();
            reader.onload = (ev) => updateStory(activeDayIdx, 'slots', activeSlotIdx + i, ev.target.result);
            reader.readAsDataURL(file);
          }
        });
      };

      const handleOverlayUpload = (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (ev) => {
            const img = new Image();
            img.onload = () => {
              const aspectRatio = img.width / img.height;
              const newOverlay = { 
                id: Date.now().toString(), 
                src: ev.target.result, 
                x: 140, 
                y: 250, 
                width: 120, 
                height: 120 / aspectRatio,
                aspectRatio 
              };
              updateStory(activeDayIdx, 'overlays', activeSlotIdx, [...currentOverlays, newOverlay]);
              setSelectedElements([{ type: 'overlay', id: newOverlay.id }]);
            };
            img.src = ev.target.result;
          };
          reader.readAsDataURL(file);
        }
        e.target.value = '';
      };

      const addTextsFromGuion = () => {
        if (!currentGuion) {
          alert('No hay gui√≥n disponible para este d√≠a');
          return;
        }

        const lines = currentGuion.textos;
        if (lines.length === 0) return;
        
        const newTexts = [];
        const font = FONTS[0];
        
        const colorSchemes = [
          { bg: '#FFCC00', color: '#000000' },
          { bg: '#FFFFFF', color: '#000000' },
          { bg: '#FF3B30', color: '#FFFFFF' },
        ];
        
        const positions = [
          { y: 80, fontSize: 28 },
          { y: 280, fontSize: 20 },
          { y: 480, fontSize: 32 },
        ];
        
        const xPositions = [120, 180, 140];
        
        const numTexts = Math.min(lines.length, 3);
        for (let i = 0; i < numTexts; i++) {
          const scheme = colorSchemes[i % colorSchemes.length];
          const pos = positions[i % positions.length];
          
          newTexts.push({ 
            id: Date.now().toString() + i, 
            content: lines[i], 
            x: xPositions[i % xPositions.length], 
            y: pos.y, 
            fontSize: pos.fontSize, 
            color: scheme.color, 
            bgColor: scheme.bg,
            bgOpacity: 1,
            fontId: font.id, 
            fontFamily: font.fontFamily,
            fontWeight: font.fontWeight,
            rotation: 0, 
            align: 'left',
            maxChars: MAX_CHARS_NARROW
          });
        }
        
        updateStory(activeDayIdx, 'texts', activeSlotIdx, [...currentTexts, ...newTexts]);
        setSelectedElements(newTexts.map(t => ({ type: 'text', id: t.id })));
      };

      const updateText = (id, updates) => {
        const newTexts = currentTexts.map(t => t.id === id ? { ...t, ...updates } : t);
        updateStory(activeDayIdx, 'texts', activeSlotIdx, newTexts);
      };

      const updateOverlay = (id, updates) => {
        const newOverlays = currentOverlays.map(o => o.id === id ? { ...o, ...updates } : o);
        updateStory(activeDayIdx, 'overlays', activeSlotIdx, newOverlays);
      };

      const updateDrawing = (id, updates) => {
        const newDrawings = currentDrawings.map(d => d.id === id ? { ...d, ...updates } : d);
        updateStory(activeDayIdx, 'drawings', activeSlotIdx, newDrawings);
      };
      
      const deleteSelected = () => {
        const textIds = selectedElements.filter(s => s.type === 'text').map(s => s.id);
        const overlayIds = selectedElements.filter(s => s.type === 'overlay').map(s => s.id);
        if (textIds.length) updateStory(activeDayIdx, 'texts', activeSlotIdx, currentTexts.filter(t => !textIds.includes(t.id)));
        if (overlayIds.length) updateStory(activeDayIdx, 'overlays', activeSlotIdx, currentOverlays.filter(o => !overlayIds.includes(o.id)));
        setSelectedElements([]);
      };

      const deleteDrawing = (id) => {
        updateStory(activeDayIdx, 'drawings', activeSlotIdx, currentDrawings.filter(d => d.id !== id));
        setSelectedDrawingId(null);
      };

      const deleteSlot = (slotIdx) => {
        updateStory(activeDayIdx, 'slots', slotIdx, null);
        updateStory(activeDayIdx, 'texts', slotIdx, []);
        updateStory(activeDayIdx, 'drawings', slotIdx, []);
        updateStory(activeDayIdx, 'overlays', slotIdx, []);
        setSelectedThumbIdx(null);
        if (activeSlotIdx === slotIdx) setActiveSlotIdx(0);
      };

      const undoLastAction = () => {
        if (currentDrawings.length > 0) {
          updateStory(activeDayIdx, 'drawings', activeSlotIdx, currentDrawings.slice(0, -1));
          setSelectedDrawingId(null);
        } else if (currentTexts.length > 0) {
          updateStory(activeDayIdx, 'texts', activeSlotIdx, currentTexts.slice(0, -1));
          setSelectedElements([]);
        } else if (currentOverlays.length > 0) {
          updateStory(activeDayIdx, 'overlays', activeSlotIdx, currentOverlays.slice(0, -1));
          setSelectedElements([]);
        }
      };

      const clearAll = () => {
        updateStory(activeDayIdx, 'texts', activeSlotIdx, []);
        updateStory(activeDayIdx, 'drawings', activeSlotIdx, []);
        updateStory(activeDayIdx, 'overlays', activeSlotIdx, []);
        setSelectedElements([]);
        setSelectedDrawingId(null);
      };

      const handleCanvasMouseDown = (e) => {
        const rect = canvasRef.current.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        if (tool === 'draw') {
          setIsDrawing(true);
          setCurrentPath([{ x, y }]);
          setSelectedElements([]);
          setSelectedDrawingId(null);
        } else {
          setSelectedElements([]);
          setSelectedDrawingId(null);
        }
      };

      const handleCanvasMouseMove = (e) => {
        if (!isDrawing || tool !== 'draw') return;
        const rect = canvasRef.current.getBoundingClientRect();
        setCurrentPath(prev => [...prev, { x: e.clientX - rect.left, y: e.clientY - rect.top }]);
      };

      const handleCanvasMouseUp = () => {
        if (isDrawing && currentPath.length > 1) {
          const newDrawing = { id: Date.now().toString(), path: currentPath, color: drawColor, size: brushSize, style: brushStyle, tip: brushTip };
          updateStory(activeDayIdx, 'drawings', activeSlotIdx, [...currentDrawings, newDrawing]);
          setSelectedDrawingId(newDrawing.id);
        }
        setIsDrawing(false);
        setCurrentPath([]);
      };

      const startDrag = (type, id, e) => {
        e.stopPropagation();
        e.preventDefault();
        setSelectedElements([{ type, id }]);
        setSelectedDrawingId(null);
        setSelectedThumbIdx(null);
        
        const startMouseX = e.clientX;
        const startMouseY = e.clientY;
        
        let item = type === 'text' ? currentTexts.find(t => t.id === id) : currentOverlays.find(o => o.id === id);
        if (!item) return;
        
        const startX = item.x;
        const startY = item.y;

        const onMove = (ev) => {
          const dx = ev.clientX - startMouseX;
          const dy = ev.clientY - startMouseY;
          const newX = startX + dx;
          const newY = startY + dy;
          if (type === 'text') updateText(id, { x: newX, y: newY });
          else updateOverlay(id, { x: newX, y: newY });
        };

        const onUp = () => {
          document.removeEventListener('mousemove', onMove);
          document.removeEventListener('mouseup', onUp);
        };

        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onUp);
      };

      const selectDrawing = (id, e) => {
        e.stopPropagation();
        setSelectedDrawingId(id);
        setSelectedElements([]);
        setSelectedThumbIdx(null);
      };

      const handleThumbDragStart = (idx) => setDraggedThumb(idx);
      const handleThumbDragOver = (e) => e.preventDefault();
      const handleThumbDrop = (idx) => {
        if (draggedThumb === null || draggedThumb === idx) return;
        const newSlots = [...currentStory.slots];
        const newTexts = [...currentStory.texts];
        const newDrawings = [...currentStory.drawings];
        const newOverlays = [...currentStory.overlays];
        [newSlots[draggedThumb], newSlots[idx]] = [newSlots[idx], newSlots[draggedThumb]];
        [newTexts[draggedThumb], newTexts[idx]] = [newTexts[idx], newTexts[draggedThumb]];
        [newDrawings[draggedThumb], newDrawings[idx]] = [newDrawings[idx], newDrawings[draggedThumb]];
        [newOverlays[draggedThumb], newOverlays[idx]] = [newOverlays[idx], newOverlays[draggedThumb]];
        setStories(prev => {
          const newStories = [...prev];
          newStories[activeDayIdx] = { ...newStories[activeDayIdx], slots: newSlots, texts: newTexts, drawings: newDrawings, overlays: newOverlays };
          return newStories;
        });
        setDraggedThumb(null);
      };

      const renderPath = (drawing, key, isPreview = false) => {
        const { path, color, size, style, tip } = drawing;
        if (path.length < 2) return null;
        
        let d = `M ${path[0].x} ${path[0].y}`;
        for (let i = 1; i < path.length; i++) d += ` L ${path[i].x} ${path[i].y}`;
        
        const isSelected = !isPreview && drawing.id === selectedDrawingId;
        
        let arrowHead = null;
        if (tip === 'arrow' && path.length >= 2) {
          const lastPoint = path[path.length - 1];
          const prevPoint = path.length > 5 ? path[path.length - 6] : path[0];
          const angle = Math.atan2(lastPoint.y - prevPoint.y, lastPoint.x - prevPoint.x);
          const arrowLength = 18 + size;
          const arrowAngle = 0.5;
          
          arrowHead = (
            <path
              d={`M ${lastPoint.x - arrowLength * Math.cos(angle - arrowAngle)} ${lastPoint.y - arrowLength * Math.sin(angle - arrowAngle)} 
                  L ${lastPoint.x + size * Math.cos(angle)} ${lastPoint.y + size * Math.sin(angle)} 
                  L ${lastPoint.x - arrowLength * Math.cos(angle + arrowAngle)} ${lastPoint.y - arrowLength * Math.sin(angle + arrowAngle)}`}
              stroke={color}
              strokeWidth={size}
              fill="none"
              strokeLinecap="round"
              strokeLinejoin="round"
              filter={style === 'neon' ? 'url(#neonGlow)' : ''}
            />
          );
        }
        
        return (
          <g key={key} onClick={(e) => !isPreview && selectDrawing(drawing.id, e)} style={{ cursor: isPreview ? 'default' : 'pointer' }}>
            {isSelected && <path d={d} stroke="rgba(0,255,255,0.5)" strokeWidth={size + 8} fill="none" strokeLinecap="round" strokeLinejoin="round" />}
            <path d={d} stroke={color} strokeWidth={size} fill="none" strokeLinecap="round" strokeLinejoin="round" filter={style === 'neon' ? 'url(#neonGlow)' : ''} />
            {arrowHead}
          </g>
        );
      };

      const splitTextIntoLines = (content, maxChars) => {
        const words = content.split(' ');
        const lines = [];
        let currentLine = '';
        
        words.forEach(word => {
          const testLine = currentLine ? currentLine + ' ' + word : word;
          if (testLine.length > maxChars && currentLine) {
            lines.push(currentLine);
            currentLine = word;
          } else {
            currentLine = testLine;
          }
        });
        if (currentLine) lines.push(currentLine);
        return lines;
      };

      const InstagramTextElement = ({ t, isSelected, onMouseDown }) => {
        const fs = t.fontSize;
        const padH = fs * 0.39;
        const padV = fs * 0.32;
        const radius = fs * 0.29;
        const lineH = fs * 1.2;
        const bgColor = t.bgColor || '#000000';
        const bgOpacity = t.bgOpacity ?? 1;
        const align = t.align || 'left';
        
        const lines = splitTextIntoLines(t.content, t.maxChars || MAX_CHARS_WIDE);
        
        const [lineWidths, setLineWidths] = useState([]);
        
        useEffect(() => {
          const measure = document.createElement('span');
          measure.style.cssText = `
            position: absolute;
            visibility: hidden;
            white-space: nowrap;
            font-family: ${t.fontFamily || 'Inter, -apple-system, sans-serif'};
            font-weight: ${t.fontWeight || 700};
            font-size: ${fs}px;
            letter-spacing: 0;
          `;
          document.body.appendChild(measure);
          
          const widths = lines.map(line => {
            measure.textContent = line || ' ';
            return measure.offsetWidth;
          });
          setLineWidths(widths);
          document.body.removeChild(measure);
        }, [t.content, fs, t.fontFamily, t.fontWeight, t.maxChars]);

        const getBgColor = () => {
          if (bgOpacity <= 0) return 'transparent';
          if (bgOpacity >= 1) return bgColor;
          const hex = bgColor.replace('#', '');
          const r = parseInt(hex.substr(0, 2), 16);
          const g = parseInt(hex.substr(2, 2), 16);
          const b = parseInt(hex.substr(4, 2), 16);
          return `rgba(${r},${g},${b},${bgOpacity})`;
        };

        const buildSteppedPath = () => {
          if (lineWidths.length === 0) return '';
          
          const n = lineWidths.length;
          const boxWidths = lineWidths.map(w => padH + w + padH);
          const maxW = Math.max(...boxWidths);
          const totalH = n * lineH + padV * 2;
          const r = radius;
          
          if (align === 'left') {
            let rights = [...boxWidths];
            for (let i = 0; i < n - 1; i++) {
              const diff = Math.abs(rights[i] - rights[i + 1]);
              if (diff < 20 && diff > 0) {
                const maxR = Math.max(rights[i], rights[i + 1]);
                rights[i] = maxR;
                rights[i + 1] = maxR;
              }
            }
            
            let d = `M ${r} 0`;
            d += ` L ${rights[0] - r} 0`;
            d += ` Q ${rights[0]} 0, ${rights[0]} ${r}`;
            
            for (let i = 0; i < n; i++) {
              const thisR = rights[i];
              const lineBottom = padV + (i + 1) * lineH;
              
              if (i < n - 1) {
                const nextR = rights[i + 1];
                const diff = nextR - thisR;
                
                if (Math.abs(diff) < 2) {
                  d += ` L ${thisR} ${lineBottom}`;
                } else if (diff < 0) {
                  const stepY = lineBottom + padV;
                  d += ` L ${thisR} ${stepY - r}`;
                  d += ` Q ${thisR} ${stepY}, ${thisR - r} ${stepY}`;
                  d += ` L ${nextR + r} ${stepY}`;
                  d += ` Q ${nextR} ${stepY}, ${nextR} ${stepY + r}`;
                } else {
                  const stepY = lineBottom - padV;
                  d += ` L ${thisR} ${stepY - r}`;
                  d += ` L ${thisR} ${stepY}`;
                  d += ` L ${nextR - r} ${stepY}`;
                  d += ` Q ${nextR} ${stepY}, ${nextR} ${stepY + r}`;
                }
              } else {
                d += ` L ${thisR} ${totalH - r}`;
                d += ` Q ${thisR} ${totalH}, ${thisR - r} ${totalH}`;
              }
            }
            
            d += ` L ${r} ${totalH}`;
            d += ` Q 0 ${totalH}, 0 ${totalH - r}`;
            d += ` L 0 ${r}`;
            d += ` Q 0 0, ${r} 0`;
            d += ' Z';
            return d;
          }
          
          if (align === 'right') {
            let lefts = boxWidths.map(w => maxW - w);
            for (let i = 0; i < n - 1; i++) {
              const diff = Math.abs(lefts[i] - lefts[i + 1]);
              if (diff < 20 && diff > 0) {
                const minL = Math.min(lefts[i], lefts[i + 1]);
                lefts[i] = minL;
                lefts[i + 1] = minL;
              }
            }
            
            let d = `M ${lefts[0] + r} 0`;
            d += ` L ${maxW - r} 0`;
            d += ` Q ${maxW} 0, ${maxW} ${r}`;
            d += ` L ${maxW} ${totalH - r}`;
            d += ` Q ${maxW} ${totalH}, ${maxW - r} ${totalH}`;
            d += ` L ${lefts[n-1] + r} ${totalH}`;
            d += ` Q ${lefts[n-1]} ${totalH}, ${lefts[n-1]} ${totalH - r}`;
            
            for (let i = n - 1; i >= 0; i--) {
              const thisL = lefts[i];
              const lineTop = padV + i * lineH;
              
              if (i > 0) {
                const prevL = lefts[i - 1];
                const diff = prevL - thisL;
                
                if (Math.abs(diff) < 2) {
                  d += ` L ${thisL} ${lineTop}`;
                } else if (diff > 0) {
                  const stepY = lineTop - padV;
                  d += ` L ${thisL} ${stepY + r}`;
                  d += ` Q ${thisL} ${stepY}, ${thisL + r} ${stepY}`;
                  d += ` L ${prevL - r} ${stepY}`;
                  d += ` Q ${prevL} ${stepY}, ${prevL} ${stepY - r}`;
                } else {
                  const stepY = lineTop + padV;
                  d += ` L ${thisL} ${stepY + r}`;
                  d += ` L ${thisL} ${stepY}`;
                  d += ` L ${prevL + r} ${stepY}`;
                  d += ` Q ${prevL} ${stepY}, ${prevL} ${stepY - r}`;
                }
              } else {
                d += ` L ${thisL} ${r}`;
                d += ` Q ${thisL} 0, ${thisL + r} 0`;
              }
            }
            
            d += ' Z';
            return d;
          }
          
          let d = `M ${r} 0`;
          d += ` L ${maxW - r} 0`;
          d += ` Q ${maxW} 0, ${maxW} ${r}`;
          d += ` L ${maxW} ${totalH - r}`;
          d += ` Q ${maxW} ${totalH}, ${maxW - r} ${totalH}`;
          d += ` L ${r} ${totalH}`;
          d += ` Q 0 ${totalH}, 0 ${totalH - r}`;
          d += ` L 0 ${r}`;
          d += ` Q 0 0, ${r} 0`;
          d += ' Z';
          return d;
        };

        const maxW = lineWidths.length > 0 ? Math.max(...lineWidths.map(w => padH + w + padH)) : 100;
        const totalH = lines.length * lineH + padV * 2;
        const path = buildSteppedPath();

        return (
          <div
            onMouseDown={onMouseDown}
            style={{
              position: 'absolute',
              left: t.x,
              top: t.y,
              transform: `translate(-50%, -50%) rotate(${t.rotation || 0}deg)`,
              cursor: 'move',
              outline: isSelected ? '2px solid #00ffff' : 'none',
              outlineOffset: 4
            }}
          >
            <div style={{ position: 'relative', display: 'inline-block', width: maxW }}>
              {bgOpacity > 0 && lineWidths.length > 0 && (
                <svg 
                  style={{ position: 'absolute', top: 0, left: 0, pointerEvents: 'none' }}
                  width={maxW}
                  height={totalH}
                >
                  <path d={path} fill={getBgColor()} />
                </svg>
              )}
              <div style={{ 
                position: 'relative',
                padding: `${padV}px ${padH}px`,
                zIndex: 1
              }}>
                {lines.map((line, i) => (
                  <div
                    key={i}
                    style={{
                      color: t.color,
                      fontSize: fs,
                      fontFamily: t.fontFamily || 'Inter, -apple-system, sans-serif',
                      fontWeight: t.fontWeight || 700,
                      lineHeight: 1.2,
                      textAlign: align,
                      whiteSpace: 'nowrap',
                      letterSpacing: '0'
                    }}
                  >
                    {line}
                  </div>
                ))}
              </div>
            </div>
          </div>
        );
      };
      
      const renderInstagramText = (t) => {
        const isSelected = selectedElements.some(s => s.type === 'text' && s.id === t.id);
        return (
          <InstagramTextElement
            key={t.id}
            t={t}
            isSelected={isSelected}
            onMouseDown={(e) => startDrag('text', t.id, e)}
          />
        );
      };

      const exportSingleStory = async (dayIdx, slotIdx) => {
        const story = stories[dayIdx];
        const image = story.slots[slotIdx];
        if (!image) return null;

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1080; 
        canvas.height = 1920;
        
        const img = new Image();
        await new Promise((resolve) => { img.onload = resolve; img.src = image; });
        
        const imgRatio = img.width / img.height;
        const canvasRatio = canvas.width / canvas.height;
        let drawWidth, drawHeight, drawX, drawY;
        
        if (imgRatio > canvasRatio) {
          drawWidth = canvas.width;
          drawHeight = canvas.width / imgRatio;
          drawX = 0;
          drawY = (canvas.height - drawHeight) / 2;
        } else {
          drawHeight = canvas.height;
          drawWidth = canvas.height * imgRatio;
          drawX = (canvas.width - drawWidth) / 2;
          drawY = 0;
        }
        
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
        
        const canvasEl = canvasRef.current;
        const elWidth = canvasEl?.offsetWidth || 370;
        const elHeight = canvasEl?.offsetHeight || 658;
        const scaleX = canvas.width / elWidth;
        const scaleY = canvas.height / elHeight;
        
        const texts = story.texts[slotIdx] || [];
        const drawings = story.drawings[slotIdx] || [];
        const overlays = story.overlays[slotIdx] || [];

        for (const overlay of overlays) { 
          const oImg = new Image(); 
          await new Promise((resolve) => { oImg.onload = resolve; oImg.onerror = resolve; oImg.src = overlay.src; });
          const oW = overlay.width * scaleX;
          const oH = overlay.height * scaleY;
          ctx.drawImage(oImg, (overlay.x * scaleX) - oW/2, (overlay.y * scaleY) - oH/2, oW, oH);
        }

        drawings.forEach(dr => { 
          ctx.beginPath(); 
          ctx.strokeStyle = dr.color; 
          ctx.lineWidth = dr.size * scaleX; 
          ctx.lineCap = 'round'; 
          ctx.lineJoin = 'round';
          if (dr.style === 'neon') { ctx.shadowColor = dr.color; ctx.shadowBlur = 15 * scaleX; }
          dr.path.forEach((p, i) => { 
            if (i === 0) ctx.moveTo(p.x * scaleX, p.y * scaleY); 
            else ctx.lineTo(p.x * scaleX, p.y * scaleY); 
          }); 
          ctx.stroke();
          
          if (dr.tip === 'arrow' && dr.path.length >= 2) {
            const lastPoint = dr.path[dr.path.length - 1];
            const prevPoint = dr.path.length > 5 ? dr.path[dr.path.length - 6] : dr.path[0];
            const angle = Math.atan2(lastPoint.y - prevPoint.y, lastPoint.x - prevPoint.x);
            const arrowLength = (18 + dr.size) * scaleX;
            const arrowAngle = 0.5;
            
            ctx.beginPath();
            ctx.moveTo(
              lastPoint.x * scaleX - arrowLength * Math.cos(angle - arrowAngle),
              lastPoint.y * scaleY - arrowLength * Math.sin(angle - arrowAngle)
            );
            ctx.lineTo(
              lastPoint.x * scaleX + dr.size * scaleX * Math.cos(angle),
              lastPoint.y * scaleY + dr.size * scaleY * Math.sin(angle)
            );
            ctx.lineTo(
              lastPoint.x * scaleX - arrowLength * Math.cos(angle + arrowAngle),
              lastPoint.y * scaleY - arrowLength * Math.sin(angle + arrowAngle)
            );
            ctx.stroke();
          }
          ctx.shadowBlur = 0;
        });

        texts.forEach(t => { 
          ctx.save(); 
          ctx.translate(t.x * scaleX, t.y * scaleY); 
          if (t.rotation) ctx.rotate(t.rotation * Math.PI / 180);
          
          const fs = t.fontSize * scaleX;
          const padH = fs * 0.39;
          const padV = fs * 0.32;
          const radius = fs * 0.29;
          const lineH = fs * 1.2;
          
          ctx.font = `${t.fontWeight || 700} ${fs}px ${t.fontFamily || 'Inter, -apple-system, sans-serif'}`;
          ctx.textBaseline = 'top';
          
          const lines = splitTextIntoLines(t.content, t.maxChars || MAX_CHARS_WIDE);
          
          const lineWidths = lines.map(line => ctx.measureText(line).width);
          
          let rights = lineWidths.map(w => padH + w + padH);
          for (let i = 0; i < rights.length - 1; i++) {
            const diff = Math.abs(rights[i] - rights[i + 1]);
            if (diff < 20 * scaleX && diff > 0) {
              const maxR = Math.max(rights[i], rights[i + 1]);
              rights[i] = maxR;
              rights[i + 1] = maxR;
            }
          }
          
          const maxRight = Math.max(...rights);
          const totalH = lines.length * lineH + padV * 2;
          const r = radius;
          const n = lines.length;
          
          const bgOpacity = t.bgOpacity ?? 1;
          if (bgOpacity > 0) {
            const bgColor = t.bgColor || '#000000';
            if (bgOpacity >= 1) {
              ctx.fillStyle = bgColor;
            } else {
              const hex = bgColor.replace('#', '');
              const rr = parseInt(hex.substr(0, 2), 16);
              const gg = parseInt(hex.substr(2, 2), 16);
              const bb = parseInt(hex.substr(4, 2), 16);
              ctx.fillStyle = `rgba(${rr},${gg},${bb},${bgOpacity})`;
            }
            
            const offsetX = -maxRight / 2;
            const offsetY = -totalH / 2;
            
            ctx.beginPath();
            ctx.moveTo(offsetX + r, offsetY);
            ctx.lineTo(offsetX + rights[0] - r, offsetY);
            ctx.quadraticCurveTo(offsetX + rights[0], offsetY, offsetX + rights[0], offsetY + r);
            
            for (let i = 0; i < n; i++) {
              const thisR = rights[i];
              const lineBottom = padV + (i + 1) * lineH;
              
              if (i < n - 1) {
                const nextR = rights[i + 1];
                const diff = nextR - thisR;
                
                if (Math.abs(diff) < 2) {
                  ctx.lineTo(offsetX + thisR, offsetY + lineBottom);
                } else if (diff < 0) {
                  const stepY = lineBottom + padV;
                  ctx.lineTo(offsetX + thisR, offsetY + stepY - r);
                  ctx.quadraticCurveTo(offsetX + thisR, offsetY + stepY, offsetX + thisR - r, offsetY + stepY);
                  ctx.lineTo(offsetX + nextR + r, offsetY + stepY);
                  ctx.quadraticCurveTo(offsetX + nextR, offsetY + stepY, offsetX + nextR, offsetY + stepY + r);
                } else {
                  const stepY = lineBottom - padV;
                  ctx.lineTo(offsetX + thisR, offsetY + stepY - r);
                  ctx.lineTo(offsetX + thisR, offsetY + stepY);
                  ctx.lineTo(offsetX + nextR - r, offsetY + stepY);
                  ctx.quadraticCurveTo(offsetX + nextR, offsetY + stepY, offsetX + nextR, offsetY + stepY + r);
                }
              } else {
                ctx.lineTo(offsetX + thisR, offsetY + totalH - r);
                ctx.quadraticCurveTo(offsetX + thisR, offsetY + totalH, offsetX + thisR - r, offsetY + totalH);
              }
            }
            
            ctx.lineTo(offsetX + r, offsetY + totalH);
            ctx.quadraticCurveTo(offsetX, offsetY + totalH, offsetX, offsetY + totalH - r);
            ctx.lineTo(offsetX, offsetY + r);
            ctx.quadraticCurveTo(offsetX, offsetY, offsetX + r, offsetY);
            ctx.fill();
          }
          
          ctx.fillStyle = t.color;
          ctx.textAlign = 'left';
          let textY = -totalH / 2 + padV;
          lines.forEach((line, i) => {
            const lineX = -maxRight / 2 + padH;
            ctx.fillText(line, lineX, textY);
            textY += lineH;
          });
          
          ctx.restore();
        });

        return { 
          dataUrl: canvas.toDataURL('image/png'), 
          name: `${DAYS[dayIdx]}-story-${slotIdx + 1}.png`,
          blob: await new Promise(resolve => canvas.toBlob(resolve, 'image/png'))
        };
      };

      const exportDay = async () => {
        const results = [];
        for (let i = 0; i < 4; i++) {
          const result = await exportSingleStory(activeDayIdx, i);
          if (result) results.push(result);
        }
        if (results.length === 0) return alert('No hay stories para exportar');
        if (results.length === 1) {
          const link = document.createElement('a'); link.download = results[0].name; link.href = results[0].dataUrl; link.click();
        } else {
          const zip = new JSZip();
          results.forEach(r => zip.file(r.name, r.dataUrl.split(',')[1], { base64: true }));
          const blob = await zip.generateAsync({ type: 'blob' });
          const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `${DAYS[activeDayIdx]}-stories.zip`; a.click();
        }
      };

      const exportAll = async () => {
        const zip = new JSZip();
        let count = 0;
        for (let d = 0; d < 7; d++) {
          for (let s = 0; s < 4; s++) {
            const result = await exportSingleStory(d, s);
            if (result) { zip.file(`${DAYS[d]}/${result.name}`, result.dataUrl.split(',')[1], { base64: true }); count++; }
          }
        }
        if (count === 0) return alert('No hay stories');
        const blob = await zip.generateAsync({ type: 'blob' });
        const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'todas-las-stories.zip'; a.click();
      };

      const handlePublish = async () => {
        if (!blogId) {
          alert('Error: No se ha especificado cuenta');
          return;
        }

        // Recopilar todos los d√≠as con contenido
        const daysWithContent = [];
        for (let dayIdx = 0; dayIdx < 7; dayIdx++) {
          const dayStories = [];
          for (let slotIdx = 0; slotIdx < 4; slotIdx++) {
            if (stories[dayIdx].slots[slotIdx]) {
              const exported = await exportSingleStory(dayIdx, slotIdx);
              if (exported) {
                dayStories.push(exported);
              }
            }
          }
          if (dayStories.length > 0) {
            daysWithContent.push({
              dayName: DAYS[dayIdx],
              dayIdx,
              stories: dayStories
            });
          }
        }

        if (daysWithContent.length === 0) {
          alert('No hay stories para publicar');
          return;
        }

        setIsPublishing(true);

        try {
          // Calcular fechas de publicaci√≥n
          const today = new Date();
          const currentDayOfWeek = today.getDay(); // 0 = Domingo, 1 = Lunes, etc.
          
          const publications = [];
          
          daysWithContent.forEach(({ dayName, dayIdx, stories: dayStories }) => {
            // Mapear √≠ndice de d√≠a a d√≠a de la semana (0-6)
            // ['Lun', 'Mar', 'Mie', 'Jue', 'Vie', 'Sab', 'Dom']
            //    1      2      3      4      5      6      0
            const targetDayOfWeek = dayIdx === 6 ? 0 : dayIdx + 1;
            
            // Calcular d√≠as hasta ese d√≠a
            let daysUntil = targetDayOfWeek - currentDayOfWeek;
            if (daysUntil < 0) daysUntil += 7; // Siguiente semana
            if (daysUntil === 0) daysUntil = 7; // Hoy = pr√≥xima semana
            
            const publicationDate = new Date(today);
            publicationDate.setDate(today.getDate() + daysUntil);
            
            // Programar cada story del d√≠a con 1 minuto de diferencia
            dayStories.forEach((story, storyIdx) => {
              const [hours, minutes] = publishHour.split(':').map(Number);
              const storyDate = new Date(publicationDate);
              storyDate.setHours(hours, minutes + storyIdx, 0, 0);
              
              publications.push({
                image: story.blob,
                scheduledTime: storyDate.toISOString(),
                dayName,
                storyNumber: storyIdx + 1
              });
            });
          });

          // Llamar al Worker de Cloudflare
          const WORKER_URL = 'https://metricool-stories.ajnietoc.workers.dev/publish';
          
          // Enviar stories una por una (Metricool API lo requiere)
          for (const pub of publications) {
            // Convert Blob to base64 data URI
            const base64Image = await new Promise((resolve) => {
              const reader = new FileReader();
              reader.onloadend = () => resolve(reader.result);
              reader.readAsDataURL(pub.image);
            });
            
            const response = await fetch(WORKER_URL, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                blogId: blogId,
                imageUrl: base64Image,
                text: `Story ${pub.dayName} ${pub.storyNumber}`,
                scheduledTime: pub.scheduledTime
              })
            });

            if (!response.ok) {
              throw new Error(`Error publicando ${pub.dayName} story ${pub.storyNumber}`);
            }
          }

          alert(`‚úÖ ${publications.length} stories programadas correctamente en Instagram`);
          setShowPublishModal(false);

        } catch (error) {
          console.error('Error publicando:', error);
          alert('‚ùå Error al publicar: ' + error.message);
        } finally {
          setIsPublishing(false);
        }
      };

      const getPublicationPreview = () => {
        const daysWithContent = [];
        for (let dayIdx = 0; dayIdx < 7; dayIdx++) {
          const count = stories[dayIdx].slots.filter(s => s !== null).length;
          if (count > 0) {
            const dayName = DAYS[dayIdx];
            const today = new Date();
            const currentDayOfWeek = today.getDay();
            const targetDayOfWeek = dayIdx === 6 ? 0 : dayIdx + 1;
            let daysUntil = targetDayOfWeek - currentDayOfWeek;
            if (daysUntil < 0) daysUntil += 7;
            if (daysUntil === 0) daysUntil = 7;
            const publicationDate = new Date(today);
            publicationDate.setDate(today.getDate() + daysUntil);
            const dateStr = publicationDate.toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit' });
            
            const [hours, minutes] = publishHour.split(':').map(Number);
            const endMinutes = minutes + count - 1;
            const timeRange = `${publishHour}-${String(hours).padStart(2, '0')}:${String(endMinutes).padStart(2, '0')}`;
            
            daysWithContent.push({ dayName, count, dateStr, timeRange });
          }
        }
        return daysWithContent;
      };

      const firstSelectedText = selectedElements.find(s => s.type === 'text');
      const selectedTextObj = firstSelectedText ? currentTexts.find(t => t.id === firstSelectedText.id) : null;

      return (
        <div className="flex flex-col h-screen bg-background-dark text-gray-300 font-display">
          {/* HEADER */}
          <header className="p-4 bg-gray-900/50 border-b border-gray-700 flex items-center justify-between shadow-sm">
            <div className="flex items-center space-x-4">
              <h1 className="text-xl font-bold text-white">Editor de Stories</h1>
              <div className="flex items-center space-x-2">
                {DAYS.map((day, i) => (
                  <button 
                    key={day} 
                    onClick={() => { setActiveDayIdx(i); setActiveSlotIdx(0); setSelectedElements([]); setSelectedDrawingId(null); }}
                    className={`px-4 py-2 text-sm font-medium rounded-md ${activeDayIdx === i ? 'bg-gradient-to-r from-pink-500 to-purple-600 text-white shadow-lg' : 'bg-gray-800 text-gray-300'}`}
                  >
                    {day}
                  </button>
                ))}
              </div>
            </div>
            
            <div className="flex items-center space-x-4">
              <div className="flex space-x-1">
                {[0, 1, 2, 3].map(i => (
                  <div 
                    key={i}
                    className={`thumbnail-item ${draggedThumb === i ? 'dragging' : ''}`}
                    draggable
                    onDragStart={() => handleThumbDragStart(i)}
                    onDragOver={handleThumbDragOver}
                    onDrop={() => handleThumbDrop(i)}
                    onDragEnd={() => setDraggedThumb(null)}
                    onClick={() => { setActiveSlotIdx(i); setSelectedElements([]); setSelectedDrawingId(null); setSelectedThumbIdx(i); }}
                    style={{ width: 40, height: 40, cursor: 'grab' }}
                    className={`flex items-center justify-center text-sm font-medium rounded-md cursor-grab ${activeSlotIdx === i ? 'border-2 border-primary bg-gray-800 text-white' : 'border border-gray-700 bg-gray-800 text-gray-400'}`}
                  >
                    {currentStory.slots[i] ? (
                      <img src={currentStory.slots[i]} alt="" className="w-full h-full object-cover rounded" />
                    ) : (
                      <span>{i + 1}</span>
                    )}
                  </div>
                ))}
              </div>
              <div className="flex items-center space-x-2">
                <button onClick={() => setShowPublishModal(true)} className="px-4 py-2 text-sm font-medium bg-gradient-to-r from-green-500 to-emerald-600 text-white rounded-md shadow-md hover:opacity-90 transition-opacity">
                  üì± Publicar en Instagram
                </button>
                <button onClick={exportDay} className="px-4 py-2 text-sm font-medium bg-primary text-white rounded-md shadow-md hover:opacity-90 transition-opacity">Exportar d√≠a</button>
                <button onClick={exportAll} className="px-4 py-2 text-sm font-medium bg-gray-700 text-gray-300 rounded-md hover:bg-gray-600 transition-colors">Exportar todos</button>
              </div>
            </div>
          </header>

          {/* MAIN CONTENT */}
          <main className="flex-grow p-4 grid grid-cols-1 lg:grid-cols-3 gap-4">
            {/* COLUMNA GUION */}
            <div className="bg-gray-900/50 p-6 rounded-lg flex flex-col">
              <h2 className="text-xs font-semibold uppercase tracking-wider text-gray-400 mb-4">
                {currentGuion ? `${DAYS[activeDayIdx]} - ${currentGuion.titulo}` : 'SIN CONTENIDO ESTE D√çA'}
              </h2>
              
              {currentGuion ? (
                <>
                  <div className="flex-grow mb-4">
                    <div className="bg-indigo-900/20 border border-purple-500 rounded-lg p-4 space-y-2">
                      {currentGuion.textos.map((texto, idx) => (
                        <p key={idx} className="text-gray-300 text-sm leading-relaxed">
                          <span className="font-bold text-purple-400">Story {idx + 1}:</span> {texto}
                        </p>
                      ))}
                    </div>
                  </div>
                  
                  <button 
                    onClick={addTextsFromGuion} 
                    className="w-full py-3 text-sm font-semibold rounded-lg bg-gradient-to-r from-emerald-500 to-teal-500 text-white hover:opacity-90 mb-4"
                  >
                    Generar textos
                  </button>

                  <div className="border-t border-gray-700 pt-4">
                    <p className="text-xs font-semibold uppercase tracking-wider text-gray-400 mb-3">Fotos sugeridas:</p>
                    <div className="grid grid-cols-2 gap-2">
                      {currentGuion.fotos.map((foto, idx) => (
                        <div key={idx} className="bg-gray-800 rounded-lg p-3 text-center">
                          <div className="text-2xl mb-1">{foto.split(' ')[0]}</div>
                          <div className="text-xs text-gray-400">{foto.substring(foto.indexOf(' ') + 1)}</div>
                        </div>
                      ))}
                    </div>
                  </div>
                </>
              ) : (
                <div className="flex-grow flex items-center justify-center">
                  <p className="text-gray-500 text-center">Este d√≠a no tiene gui√≥n asignado.<br/>Sube tus fotos y crea el contenido manualmente.</p>
                </div>
              )}
            </div>

            {/* COLUMNA TOOLS */}
            <div className="bg-gray-900/50 p-6 rounded-lg flex flex-col space-y-6 overflow-y-auto">
              {/* Dibujo */}
              <div>
                <h3 className="text-lg font-bold text-white mb-4">Dibujo</h3>
                <div className="grid grid-cols-2 gap-2 mb-4">
                  <button onClick={() => setBrushStyle('normal')} className={`py-3 text-sm font-medium rounded-lg ${brushStyle === 'normal' ? 'bg-gradient-to-r from-pink-500 to-purple-600 text-white shadow-lg' : 'bg-gray-800 text-gray-300'}`}>Normal</button>
                  <button onClick={() => setBrushStyle('neon')} className={`py-3 text-sm font-medium rounded-lg ${brushStyle === 'neon' ? 'bg-gradient-to-r from-pink-500 to-purple-600 text-white shadow-lg' : 'bg-gray-800 text-gray-300'}`}>Neon</button>
                  <button onClick={() => setBrushTip('normal')} className={`py-3 text-sm font-medium rounded-lg ${brushTip === 'normal' ? 'bg-gradient-to-r from-pink-500 to-purple-600 text-white shadow-lg' : 'bg-gray-800 text-gray-300'}`}>L√≠nea</button>
                  <button onClick={() => setBrushTip('arrow')} className={`py-3 text-sm font-medium rounded-lg ${brushTip === 'arrow' ? 'bg-gradient-to-r from-pink-500 to-purple-600 text-white shadow-lg' : 'bg-gray-800 text-gray-300'}`}>Flecha</button>
                </div>
                <p className="text-sm text-gray-400 mb-2">Colores dibujo</p>
                <div className="flex flex-wrap gap-2 mb-4">
                  {DRAW_COLORS.map(c => (
                    <button key={c} onClick={() => setDrawColor(c)} className="w-6 h-6 rounded-full" style={{ background: c, border: drawColor === c ? '2px solid white' : '2px solid transparent' }} />
                  ))}
                </div>
                <div className="grid grid-cols-2 gap-2">
                  <button onClick={undoLastAction} className="flex items-center justify-center py-2 bg-gray-800 text-gray-300 rounded-lg hover:bg-gray-700"><span className="material-icons mr-2">undo</span>Deshacer</button>
                  <button onClick={clearAll} className="py-2 bg-red-800/80 text-white rounded-lg hover:bg-red-700/80">Borrar</button>
                </div>
              </div>

              {/* Textos */}
              <div>
                <h3 className="text-lg font-bold text-white mb-4">Textos</h3>
                <div className="grid grid-cols-4 gap-2 mb-4">
                  {FONTS.map(f => (
                    <button key={f.id} onClick={() => selectedTextObj && updateText(firstSelectedText.id, { fontId: f.id, fontFamily: f.fontFamily, fontWeight: f.fontWeight })} className={`py-2 text-xs rounded-lg ${selectedTextObj?.fontId === f.id ? 'bg-gradient-to-r from-pink-500 to-purple-600 text-white' : 'bg-gray-800 text-gray-300'} ${selectedTextObj ? '' : 'opacity-50'}`}>{f.name}</button>
                  ))}
                </div>
                <div className="grid grid-cols-3 gap-2 mb-4">
                  {['left', 'center', 'right'].map((a, i) => (
                    <button key={a} onClick={() => selectedTextObj && updateText(firstSelectedText.id, { align: a })} className={`py-2 text-xs rounded-lg ${selectedTextObj?.align === a ? 'bg-gradient-to-r from-pink-500 to-purple-600 text-white' : 'bg-gray-800 text-gray-300'} ${selectedTextObj ? '' : 'opacity-50'}`}>{['Izq', 'Centro', 'Der'][i]}</button>
                  ))}
                </div>
                <p className="text-sm text-gray-400 mb-2">Color texto</p>
                <div className="flex flex-wrap gap-2 mb-4">
                  {TEXT_COLORS.map(c => (
                    <button key={c} onClick={() => selectedTextObj && updateText(firstSelectedText.id, { color: c })} className={`w-6 h-6 rounded-md ${selectedTextObj ? '' : 'opacity-50'}`} style={{ background: c, border: selectedTextObj?.color === c ? '2px solid white' : '2px solid transparent' }} />
                  ))}
                </div>
                <p className="text-sm text-gray-400 mb-2">Color fondo (Shift+rueda = opacidad)</p>
                <div className="flex flex-wrap gap-2 mb-4">
                  {['#000000', '#FFFFFF', '#FF3B30', '#FF9500', '#FFCC00', '#34C759', '#007AFF', '#AF52DE'].map(c => (
                    <button key={c} onClick={() => selectedTextObj && updateText(firstSelectedText.id, { bgColor: c })} className={`w-6 h-6 rounded-md ${selectedTextObj ? '' : 'opacity-50'}`} style={{ background: c, border: selectedTextObj?.bgColor === c ? '2px solid cyan' : '2px solid transparent' }} />
                  ))}
                </div>
                <div className="grid grid-cols-2 gap-2">
                  <button onClick={undoLastAction} className="flex items-center justify-center py-2 bg-gray-800 text-gray-300 rounded-lg hover:bg-gray-700"><span className="material-icons mr-2">undo</span>Deshacer</button>
                  <button onClick={clearAll} className="py-2 bg-red-800/80 text-white rounded-lg hover:bg-red-700/80">Borrar</button>
                </div>
              </div>

              {/* Botones Dibujar y Captura */}
              <div className="mt-auto pt-4 border-t border-gray-700">
                <div className="grid grid-cols-2 gap-2">
                  <button onClick={() => setTool(tool === 'draw' ? 'select' : 'draw')} className={`py-3 text-sm font-medium rounded-lg transition-colors ${tool === 'draw' ? 'bg-gradient-to-r from-pink-500 to-purple-600 text-white shadow-lg' : 'bg-gray-800 text-gray-300 hover:bg-gray-700'}`}>
                    <span className="material-icons mr-1" style={{ fontSize: 16, verticalAlign: 'middle' }}>brush</span> Dibujar
                  </button>
                  <button onClick={() => overlayInputRef.current?.click()} className="py-3 text-sm font-medium bg-gray-800 text-gray-300 rounded-lg hover:bg-gray-700 transition-colors">
                    <span className="material-icons mr-1" style={{ fontSize: 16, verticalAlign: 'middle' }}>photo_camera</span> Captura
                  </button>
                </div>
              </div>
            </div>

            {/* COLUMNA CANVAS */}
            <div className="bg-gray-900/50 p-4 rounded-lg flex items-center justify-center">
              <div 
                ref={canvasRef} 
                className="bg-black relative overflow-hidden h-full"
                style={{ aspectRatio: '9/16', cursor: tool === 'draw' ? 'crosshair' : 'default' }}
                onMouseDown={handleCanvasMouseDown}
                onMouseMove={handleCanvasMouseMove}
                onMouseUp={handleCanvasMouseUp}
                onMouseLeave={handleCanvasMouseUp}
              >
                {currentImage ? (
                  <img src={currentImage} alt="" className="absolute inset-0 w-full h-full object-contain pointer-events-none" draggable={false} />
                ) : (
                  <div onClick={() => fileInputRef.current?.click()} className="absolute inset-0 flex flex-col items-center justify-center bg-indigo-900/20 border-2 border-dashed border-gray-600 cursor-pointer">
                    <span className="material-icons text-4xl text-gray-500">add</span>
                    <p className="text-gray-400">Sube una imagen</p>
                  </div>
                )}

                <svg style={{ position: 'absolute', inset: 0, width: '100%', height: '100%', pointerEvents: 'none' }}>
                  <defs>
                    <filter id="neonGlow" x="-50%" y="-50%" width="200%" height="200%">
                      <feGaussianBlur stdDeviation="3" result="blur" />
                      <feMerge><feMergeNode in="blur" /><feMergeNode in="blur" /><feMergeNode in="SourceGraphic" /></feMerge>
                    </filter>
                  </defs>
                  <g style={{ pointerEvents: 'auto' }}>
                    {currentDrawings.map((d, i) => renderPath(d, i))}
                    {isDrawing && currentPath.length > 1 && renderPath({ path: currentPath, color: drawColor, size: brushSize, style: brushStyle, tip: brushTip }, 'current', true)}
                  </g>
                </svg>

                {currentOverlays.map(o => (
                  <div key={o.id} onMouseDown={(e) => startDrag('overlay', o.id, e)} style={{ position: 'absolute', left: o.x, top: o.y, transform: 'translate(-50%, -50%)', width: o.width, height: o.height, cursor: 'move', outline: selectedElements.some(s => s.type === 'overlay' && s.id === o.id) ? '2px solid #00ffff' : 'none' }}>
                    <img src={o.src} alt="" style={{ width: '100%', height: '100%', objectFit: 'contain', pointerEvents: 'none' }} draggable={false} />
                  </div>
                ))}

                {currentTexts.map(t => renderInstagramText(t))}
              </div>
            </div>
          </main>

          <input ref={fileInputRef} type="file" accept="image/*" multiple onChange={handleImageUpload} style={{ display: 'none' }} />
          <input ref={overlayInputRef} type="file" accept="image/*" onChange={handleOverlayUpload} style={{ display: 'none' }} />

          {/* MODAL DE PUBLICACI√ìN */}
          {showPublishModal && (
            <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50" onClick={() => !isPublishing && setShowPublishModal(false)}>
              <div className="bg-gray-800 rounded-lg p-6 max-w-md w-full mx-4" onClick={e => e.stopPropagation()}>
                <h2 className="text-2xl font-bold text-white mb-4">üì± Publicar en Instagram</h2>
                
                {getPublicationPreview().length === 0 ? (
                  <p className="text-gray-400 mb-6">No hay stories para publicar</p>
                ) : (
                  <>
                    <div className="bg-gray-900 rounded-lg p-4 mb-4">
                      <p className="text-sm text-gray-400 mb-2">D√≠as con contenido:</p>
                      {getPublicationPreview().map(({ dayName, count, dateStr, timeRange }) => (
                        <div key={dayName} className="flex justify-between items-center py-2 border-b border-gray-700 last:border-0">
                          <span className="text-white font-medium">{dayName} {dateStr}</span>
                          <span className="text-gray-400 text-sm">{timeRange} ({count})</span>
                        </div>
                      ))}
                      <p className="text-xs text-gray-500 mt-3">
                        Total: {getPublicationPreview().reduce((sum, d) => sum + d.count, 0)} stories
                      </p>
                    </div>

                    <div className="mb-6">
                      <label className="block text-sm font-medium text-gray-400 mb-2">Hora de inicio diaria:</label>
                      <input 
                        type="time" 
                        value={publishHour}
                        onChange={e => setPublishHour(e.target.value)}
                        disabled={isPublishing}
                        className="w-full px-4 py-2 bg-gray-900 border border-gray-700 rounded-lg text-white focus:ring-2 focus:ring-green-500"
                      />
                      <p className="text-xs text-gray-500 mt-1">Stories publicadas cada minuto a partir de esta hora</p>
                    </div>

                    <div className="flex space-x-3">
                      <button 
                        onClick={() => setShowPublishModal(false)}
                        disabled={isPublishing}
                        className="flex-1 py-3 bg-gray-700 text-white rounded-lg hover:bg-gray-600 disabled:opacity-50"
                      >
                        Cancelar
                      </button>
                      <button 
                        onClick={handlePublish}
                        disabled={isPublishing}
                        className="flex-1 py-3 bg-gradient-to-r from-green-500 to-emerald-600 text-white rounded-lg hover:opacity-90 disabled:opacity-50"
                      >
                        {isPublishing ? 'Publicando...' : 'Programar'}
                      </button>
                    </div>
                  </>
                )}
              </div>
            </div>
          )}
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<StoriesEditor />);
  </script>
</body>
</html>
